
架构师之路精选
====================

#### 互联网架构如何实现“高并发”
* 什么是高并发：通过设计保证系统能够同时并行处理很多请求
  - 相关指标：响应时间、吞吐量、QPS
* 如何提升并发能力
  - 垂直扩展（Scale Up）：业务发展前期建议使用（效果最快）
    - 提升单机处理能力：
      - 增强硬件：增加CPU数、升级网卡、升级硬盘、内存
      - 增强架构性能：缓存减少IO，异步增加吞吐量、无锁数据结构减少响应时间
  - 水平扩展(Scale Out)：终极方案
    - 常见互联网分层架构：客户端层、反向代理层、站点应用层、服务层、数据-缓存层、数据-数据库层
    - 分层水平扩展实践
      - 反向代理层：DNS轮询
      - 站点层：通过nginx实现，设置多个web后端
      - 服务层：通过服务连接池实现
      - 数据层：垂直拆分、水平拆分（按范围拆、按哈希拆）
        
#### TCP接入层的负载均衡、高可用、扩展性架构
* TCP是有状态的连接，一个client发起的请求必须落在同一台tcp-server上，如何做负载均衡，如何保证水平扩展呢
  - 单机法tcp-server：
    - 优点：请求一致性
    - 缺点：无法保证高可用
  - 集群法tcp-server，客户端实现负载均衡（配置多个外网IP，随机选择其一）
    - 优点：可保证高可用
    - 缺点：多一次DNS访问，难以预防DNS劫持
      - 改进：将IP配置在客户端（IP直通车）
        - 缺点：扩展性差，如IP变化、新增都需要更新客户端
  - 服务端实施负载均衡（根本上解决问题）
    - 增加一个http接口，将客户端的“IP配置”与“均衡策略”放到服务端，client每次访问tcp-server前，先调用一个新增的get-tcp-ip接口，这个http接口只返回一个tcp-server的IP
      - 优点：解决扩展性问题
      - 缺点：接口不知道tcp-server集群中每台服务器是否可用
  - tcp-server状态上报
    - 优点：解决上面问题
    - 缺点：反向依赖
  - tcp-server状态拉取
    - 优点：解决上面问题
    
#### 跨公网调用的大坑与架构优化方案
* 缘起
  - 业务需要跨公网调用一个第三方服务提供的接口，往往抽象出一个服务
  - 调用流程：1）业务方调用内部服务，2）内部服务跨公网调用三方，3）三方返回结果， 4）内部服务返回结果给业务方
    - 存在问题：某个调三方接口超时，会导致所有接口不可用
* 异步代理法
  - 异步代理服务定期跨公网调用三方服务，刷新本地数据
  - 优点：解决接口超时问题
  - 缺点：不是最新数据
* 第三方接口备份与切换法
  - 超时后调用第二个备份三方服务，直到超时服务恢复
  - 优点：解决超时问题
  - 缺点：不是所有三方有备用接口
* 异步调用法
  - 本地写成功就算成功，异步向第三方同步数据    
    
#### DNS在架构设计中的巧用
* 反向代理水平扩展
  - 配置多个nginx的外网IP，轮询返回
* web-server负载均衡（很少用）
  - 优点：第三方实施，不用改动架构；减少一层网络请求
  - 缺点：只具备解析功能，不保证IP的可用性（nginx做反向代理有保活探测机制，能自动迁移流量）；web-server扩容时，dns个性生效时间长
* 用户就近访问：智能DNS
  
#### 到底什么时候该使用MQ？
* 消息总线（Message Queue），后文称MQ，是一种跨进程的通信机制，用于上下游传递消息。
* 什么时候不使用MQ：上游实时关注执行结果
  - 缺点：1）系统更复杂，2）消息传递路径更长，延时增加，3）消息可靠性和重复性互相矛盾，4）上游无法知道下游执行结果
* 什么时候使用MQ
  - 场景一：数据驱动的任务依赖
    - 常规作法：cron定时执行
      - 缺点：1）超时问题严重；2）执行时间很长，预留大量buffer；3）依赖关系容易出错；4）调整一个任务影响很大
    - 优化方案：采用MQ解耦
      - 优点：1）不需要预留buffer；2）方便处理依赖；3）调整任务，不影响下游执行时间
  - 场景二：上游不关心执行结果
    - 优点：1）上游执行时间短；2）上下游逻辑解耦；3）新增下游，不用改上游
  - 场景三：上游关心执行结果，但执行时间很长
    - 三方服务，回调网关通知MQ  
  
#### 消息总线能否实现消息必达？
* MQ要想尽量消息必达，架构上有两个核心设计点：1）消息落地；2）消息超时、重传、确认

#### 消息总线真的能保证幂等？
* MQ-Client发消息给MQ-Server
  - 对每条消息，S内部生成inner-msg-id，用于去重，其特征：1）全局唯一；2）MQ生成，无业务无关
* MQ-Server发消息给MQ-Client
  - 生成biz-id，用于去重，其特征：1）同一业务场景全局唯一；2）由业务发送方生成，对MQ透明；3）业务消费方负责判重，保证幂等
  - 常见业务ID：支付ID，帖子ID
* 幂等性，不仅对MQ有要求，对业务上下游也有要求。
  
#### MQ，如何做到消息延时
* 常见方案：启动一个cron定时任务，每小时执行一次
  - 缺点：1）轮询效率低；2）重复计算；3）时效性不好，误差大；
* 高效延时消息设计与实现
  - 环形队列：例如一个3600个slot的队列
  - 任务集合：每个slot是一个Set<Task>
  - timer每秒移动一格，Cycle-Num为0则处理任务，否则减1
  - 优点：1）无需轮询；2）一个任务只执行一次；3）时效性好，精确到秒  
  
#### MQ如何快速实现流量削峰填谷
* 常见方案：1）上游队列缓冲，限速发送；2）下游队列缓冲，限速执行
* MQ缓冲方式：
  - 由MQ-Server推模式，改为MQ-Client拉模式
  - 如果MQ-Server堆积消息过多，Client要改进为批量写，提高吞吐量  
  

#### 消息安全传输中的技术点
* 初级阶段：在网络上传递明文，非常危险
* 传输密文
  - 客户端和服务端约定好加密算法和密钥
  - 缺点：客户端代码不安全
* 服务端为每个用户生成密钥
  - 客户端和服务端提前约定好加密算法，在传递消息前，先协商密钥
* 客户端确定密钥，密钥不再传输（弱安全）
  - 特点：
    - 使用“具备用户特性的东西”作为加密密钥，例如：用户密码的散列值
    - 一人一密，每个人的密钥不同
* 一次一密，密钥协商
  - 过程
    - 服务端随机生成公私钥对(公钥pk1，私钥pk2)，并将公钥pk1传给客户端
    - 客户端随机生成公私钥对(公钥pk11，私钥pk22)，并将公钥pk22，通过pk1加密，传给服务端
    - 服务端随机生成对称加密密钥key=X，用pk11加密，传给客户端
* 总结
  - 1）网络上传递的数据是不安全的；2）客户端的代码是不安全的；3）客户端内存是安全的；
  
#### 互联网分层架构的本质
* 典型互联网分层架构：1）客户端；2）应用层；3）数据缓存层；4）数据库层
  - 服务化：2，3之间添加一个服务层
* 同层次MVC分层
* 互联网分层架构，是一个数据移动，处理，呈现的过程，其中数据移动是整个过程的核心
* 数据移动的两个重点：1）数据传输的格式；2）数据在各层次的形态
  - 数据传输的格式[协议]
    - service与db/cache之间，二进制协议/文本协议
    - web-server与service之间，RPC的二进制协议
    - client和web-server之间，http协议
  - 数据在各层次的形态
    - db层，数据是以“行”为单位存在的row(uid, name, age)
    - cache层，数据是以kv的形式存在的kv(uid -> User)
    - service层，会把row或者kv转化为对程序友好的User对象
    - web-server层，会把对程序友好的User对象转化为对http友好的json对象
    - client层：最终端上拿到的是json对象
* 核心原则与方法：封装（下游屏蔽数据的获取细节）和复用（上游高效地获取和处理数据） 
  
#### 互联网架构为什么要做服务化？
* 为什么要服务化
  - 架构痛点一：代码到处拷贝 - 各个业务线都是自己通过DAO写SQL访问库
  - 架构痛点二：复杂性扩散 - 各个业务线都需要关注缓存的引入导致的复杂性
  - 架构痛点三：库的复用与耦合
  - 架构痛点四：SQL质量得不到保障，业务相互影响
  - 架构痛点五：疯狂的DB耦合  
  
#### 互联网分层架构之-DAO与服务化
* 什么时候进行DAO层的抽象
  - 当手写代码从DB中获取数据，成为通用痛点的时候，就应该抽象出DAO层，简化数据获取过程，提高数据获取效率，向上游屏蔽底层的复杂性
* 什么时候进行数据服务层的抽象
  - 当业务越来越复杂，垂直拆分的系统越来越多，数据库实施了水平切分，数据层实施了缓存加速之后，底层数据获取复杂性成为通用痛点的时候，就应该抽象出数据服务层，简化数据获取过程，提高数据获取效率，向上游屏蔽底层的复杂性
  - 服务化的缺点：1）请求处理时间增加；2）运维复杂；3）定时问题更麻烦  
  
#### 业务层是否也需要服务化
* 业务层是否需要服务化
  - 是否需要抽象通用业务服务，和业务复杂性，以及业务发展阶段有关，不可一概而论
* 什么时候服务化
  - 业务越来越复杂，垂直拆分的系统越来越多，基础数据服务越来越多，底层数据获取复杂性成为通用痛点的时候，就应该抽象出通用业务服务，简化数据获取过程，提高数据获取效率，向上游屏蔽底层的复杂性  
  
#### 为什么要引入数据库中间件
* 数据量增大，性能会降低，开始对DB进行切分，原来SQL支持的功能，需要base-service层来进行特殊处理
  - 有些数据需要路由到特定的水平切分库
  - 有些数据不确定落在哪一个水平切分库，就需要访问所有库
  - 有些数据需要访问全局的库，拿到数据的全局视野，到service层进行额外处理
* 带来的问题：1）base-service层的复杂度提高了；2）数据获取效率降低了
* 解决方案，引入中间件db-proxy
* 结论：当数据库水平切分，base-service层获取db数据过于复杂，成为通用痛点的时候，就应该抽象出数据库中间件，简化数据获取过程，提高数据获取效率，向上游屏蔽底层的复杂性。  
  
#### APP分层架构设计随想
* 问题：大量复制代码，无法重用
  - 原因：1）早期业务压力大，没做规划；2）后期代码不敢动，怕出问题；3）一个人图省事；
* 分层：
  - 1）View-展现层；
  - 2）Controller-服务层，实现业务逻辑，提供封装和复用；
  - 3）Model-数据层，
    - 同步获取：通过文件，内存，本地数据库获取
    - 异步获取：从server获取，往往通过回调实现  
  
#### 架构解耦
* 耦合，是架构中，本来不相干的代码、模块、服务、系统因为某些原因联系在一起，各自独立性差，影响则相互影响，变动则相互变动的一种架构状态。
  - 如何发现：明明不应该联动，却要被动配合，就可能有潜在的耦合
* IP耦合
  - 如何解决：使用内网域名替代内网IP
* 公共库耦合
  - 如何解决：通常是方案二，三同时使用
    - 方案一：代码拷贝一份，但缺点很多
    - 方案二：垂直拆分，拆出业务个性化代码
    - 方案三：服务化，将通用代码拆到下层
* 数据库耦合
  - 公用业务表和独立业务数据表，必须在同一个数据库实例里，形成耦合
  - 如何解决
    - 第一步：公共数据访问下沉服务化 - 业务层只能通过服务RPC接口访问数据；任何上游不允许跨过服务访问底层的user库
    - 第二步：垂直拆分，个性化数据访问上浮 - 服务化+垂直拆分后，变成两次访问，一次获取业务数据，一次获取通用数据
  - 优点：数据库解耦
  - 缺点：业务代码复杂，多次访问，SQL中的逻辑计算迁移到业务代码中
* MQ，互联网架构解耦神器
  - 如果事件发出方关注下游执行执行结果，用RPC；不关心订阅方的执行结果，应该用MQ
* 配置中心，互联网架构解耦利器  
  
### 资料链接
* [架构师之路精选](https://mp.weixin.qq.com/s/CIPosICgva9haqstMDIHag)